#summary BEARについて(en)
#labels Manual,Phase-Design

= BEAR概要 =

[http://www.bear-project.net/blog/wp-content/uploads/2011/07/bear_prv.gif]

BEAR is a resource oriented framework.

== 3 components ==
  * *page* request resource, push to view
  * *resource* a information with interface with URI (REST)
  * *view* resource representation

This is simple example to have HTML.

  # user request page, page request resource with read method.
  # retrieved data pushed to view, then it become HTML

= A Resource Oriented Design =

In BEAR, model is used as "resource"

"resource model" has no particular own method like "object model", Instead of method. The resource has unified request interface.(REST)

Let's assume HTML page as representation of resource. for instance, the blog entry page is as visualized resource of "blog page resource". One page contains single or multiple resource. "entry resource" will have a "comment resource" or "trackback resource" Each resource is liked each other and have a view template for representation.

BEAR resource model structure is flat. Data source(DB) / model / view has less "impedance mismatch"（[http://en.wikipedia.org/wiki/Object-relational_impedance_mismatch )

Not only "push" from page to view, but "pull" from view to resource is also available. Lazy request is also supported.Reusability of resource is also BEAR's feature. You can use resource not only "page" (controller), but also console or batch even socket is available. This functionality brought smoothly because its all resource oriented design.

Resource can have multiple representation, HTML for PC, Mobile or web service data (JSON/XML)
). Using "resource template" enables separation of resource value and its representation.

Resource works as "service layer", Using DB or remote XML, local CSV file under that layer enable same usage and get same benefit in all resource, such as cache, log, or paging. It also enable multiple layering system.(REST)  

Some framework deal with model as data source, or some say model should be "domain model" which has self disciplines.

In BEAR, resource woks as data source, service layer, or domain model.This is based on the idea model define is designed by application, not by framework. for instance, "today's notification" is enough as data source. but "train service management" is not enough with active record, I think.

More than component itself or how to behave as model, The link and framework of application and more focused. These are connected with "REST", That's basic architecture of "BEAR".

= ページ設計 =

webサイトを「URLを単なるコントローラやモデル呼び出し用の引数とする一つの大きなwebアプリケーション」として考えるより、「1URLがそれぞれ独立したページリソースを表現するリソースの集合体」のように考え*ページ設計*を主体とします。フロントコントローラーではなくページコントローラーです。

リソースであるページは、多くの場合他のリソースを読み出し合成してビューにPUSHします。リソースのレイヤリングです。たとえば「ユーザーページリソース」は「ユーザーリソース」と共に「ユーザーの友達リソース」「ユーザーのプロファイルリソース」などのリソースにreadリクエストを行い得られた「ページリソース」の結果をテンプレートと合成してHTMLで表現します。

*1URL* につき *1ページクラス* を用意し、ページクラスにページの*イベントハンドラ* を記述します。メインクラスはそのページのハンドラーをイベントに応じて呼び出しオブジェクトをページを動作させます。ページが最終的に返すhttpリソースが最終的に出力されHTMLとして表現されます。

|| *イベント* || *ページメソッド* || 
|| 注入 || onInject() || 
|| 初期化 || onInit(array $args) || 
|| 表示 || onOutput() ||
|| サブミットOK || onAction(array $submit) ||
|| アクティブリンククリック ||  onClick($id) ||
|| 例外 ||  onExecption(Exception $e) ||

ページではonAction, onClick()などページイベント発火したときにコールされる処理を記述します。
BEARではonで始まるイベントハンドラメソッドを記述することがプログラムの中心になります。

= DI（依存性の注入）=

オブジェクトの生成、設定、依存の注入を専用で行うDIツールを用いることで、オブジェクトの生成や依存する利用オブジェクトの関係やインスタンス管理を柔軟にコントロールでき、テストや変更がより容易になります。

BEARの多くのフレームワークコンポーネントがフレームワークソースを触る事なしに自作のコンポーネントと差し替え可能です。またオブジェクトの遅延生成やインジェクトキャッシュも可能です。これはすべてクラスが統一されたインターフェイス（コンストラクタと設定、インジェクト）を持ち、DIツールが全てのサービスオブジェクトをグローバルレジストリでシングルトン管理するサービスロケーターにより実現されています。

=スペック=


==基本仕様==

    * PHP5.2+
    * 基本ライブラリはPEAR 
    * フルスタックでなくプラガブル
    * ViewはデフォルトでSmarty
    * UAスニッフィング（携帯/モバイル端末他/複数ブラウザ対応）
    * エンコードは携帯含めて全てUTF-8
    * 二重投稿、CSRF対策などのセキュリティ機構
    * ログ、キャッシュ(File/APC/Memcache)、イメージ(GD/iMagick/Cairo)
    * エラーハンドラ、デバックツール
    * オンラインエディター
    * コマンドラインインターフェイス
    * オートローダー標準
    * PEAR/Zendスタイルコーディング
    * ソケットサービス


= More about BEAR =

コンセプト、より専門的な設計指針、影響を受けたフレームワーク、ライブラリやその他情報ソースについては[software_design ソフトウェアデザイン]をご覧ください。
